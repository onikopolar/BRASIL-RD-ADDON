import { addonBuilder } from 'stremio-addon-sdk';
const express = require('express');
const cors = require('cors');
import { StreamHandler } from './services/StreamHandler';
import { RealDebridService } from './services/RealDebridService';
import { CacheService } from './services/CacheService';
import { Logger } from './utils/logger';
import { StreamRequest } from './types';

const logger = new Logger('Main');
const streamHandler = new StreamHandler();
const cacheService = new CacheService();
const app = express();

// Cache para links já resolvidos usando CacheService
const CACHE_TTL = 24 * 60 * 60 * 1000; // 24 horas

// Configuração do Express
app.use(cors());
app.use(express.json());

// Manifest do addon
const manifest = {
    id: 'org.brasilrd.addon',
    version: '1.0.0',
    name: 'Brasil RD',
    description: 'Addon brasileiro com suporte completo ao Real-Debrid',

    logo: 'https://raw.githubusercontent.com/Stremio/stremio-art/main/placeholder/icon-256.png',
    background: 'https://raw.githubusercontent.com/Stremio/stremio-art/main/placeholder/background-1920x1080.jpg',
    contactEmail: '',

    resources: ['stream'],
    types: ['movie', 'series'],
    catalogs: [],
    idPrefixes: ['tt', 'tmdb', 'tvdb', 'imdb'],

    behaviorHints: {
        configurable: true,
        configurationRequired: true,
        adult: false,
        p2p: true
    },

    config: [
        {
            key: 'apiKey',
            type: 'text',
            title: 'Configuração Real-Debrid - Obtenha sua chave API (real-debrid.com/apitoken)',
            required: true,
            placeholder: 'Site: real-debrid.com/apitoken - Cole a chave aqui'
        }
    ]
};

const builder = new addonBuilder(manifest as any);

// Handler principal de streams
builder.defineStreamHandler(async (args: any) => {
    const requestStartTime = Date.now();

    const config = args.config;

    if (!config || !config.apiKey) {
        logger.warn('Requisição de stream sem API key configurada', {
            type: args.type,
            id: args.id
        });
        return { streams: [] };
    }

    const streamRequest: StreamRequest = {
        type: args.type as 'movie' | 'series',
        id: args.id,
        title: '',
        apiKey: config.apiKey,
        config: {
            quality: 'Todas as Qualidades',
            maxResults: '15 streams',
            language: 'pt-BR',
            enableAggressiveSearch: true,
            minSeeders: 2,
            requireExactMatch: false,
            maxConcurrentTorrents: 8
        }
    };

    logger.info('Processando requisição de stream', {
        type: args.type,
        id: args.id,
        apiKey: config.apiKey.substring(0, 8) + '...'
    });

    try {
        const result = await streamHandler.handleStreamRequest(streamRequest);
        const processingTime = Date.now() - requestStartTime;

        logger.info('Streams processados com sucesso', {
            requestId: args.id,
            streamsCount: result.streams.length,
            processingTime: processingTime + 'ms',
        });

        if (result.streams.length > 0) {
            logger.debug('Nomes dos streams encontrados', {
                streamNames: result.streams.map(s => s.name)
            });
        }

        if (result.streams.length < 5) {
            logger.warn('Poucos streams encontrados', {
                requestId: args.id,
                streamsFound: result.streams.length,
                type: args.type,
                id: args.id
            });
        }

        return result;

    } catch (error) {
        const errorTime = Date.now() - requestStartTime;

        logger.error('Falha no processamento de streams', {
            error: error instanceof Error ? error.message : 'Unknown error',
            request: { type: args.type, id: args.id },
            processingTime: errorTime + 'ms'
        });

        return { streams: [] };
    }
});

// Configuração de cache
const cacheMaxAge = 600;

// Middleware de cache
app.use((req: any, res: any, next: any) => {
    if (cacheMaxAge && !res.getHeader('Cache-Control')) {
        res.setHeader('Cache-Control', 'max-age=' + cacheMaxAge + ', public');
    }
    next();
});

// Servir o manifest
app.get('/manifest.json', (req: any, res: any) => {
    const { config } = req.query;
    let manifestResp = manifest;
    
    if (config && manifest.behaviorHints && (manifest.behaviorHints.configurationRequired || manifest.behaviorHints.configurable)) {
        const manifestClone = JSON.parse(JSON.stringify(manifest));
        delete manifestClone.behaviorHints.configurationRequired;
        delete manifestClone.behaviorHints.configurable;
        manifestResp = manifestClone;
    }
    
    res.setHeader('Content-Type', 'application/json; charset=utf-8');
    res.json(manifestResp);
});

// Página de configuração
app.get('/configure', (req: any, res: any) => {
    const landingHTML = `
        <!DOCTYPE html>
        <html>
        <head>
            <title>${manifest.name}</title>
            <meta name="viewport" content="width=device-width, initial-scale=1">
            <style>
                body { font-family: Arial, sans-serif; margin: 40px; background: #f5f5f5; }
                .container { max-width: 600px; margin: 0 auto; background: white; padding: 30px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
                h1 { color: #333; margin-bottom: 20px; }
                .form-group { margin-bottom: 20px; }
                label { display: block; margin-bottom: 5px; font-weight: bold; color: #555; }
                input[type="text"] { width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 16px; }
                .help-text { font-size: 14px; color: #666; margin-top: 5px; }
                .submit-btn { background: #007cba; color: white; border: none; padding: 12px 24px; border-radius: 4px; cursor: pointer; font-size: 16px; }
                .submit-btn:hover { background: #005a87; }
            </style>
        </head>
        <body>
            <div class="container">
                <h1>${manifest.name}</h1>
                <p>${manifest.description}</p>
                <form id="configForm">
                    <div class="form-group">
                        <label for="apiKey">Chave API do Real-Debrid</label>
                        <input type="text" id="apiKey" name="apiKey" placeholder="${manifest.config[0].placeholder}" required>
                        <div class="help-text">${manifest.config[0].title}</div>
                    </div>
                    <button type="submit" class="submit-btn">Salvar Configuração</button>
                </form>
            </div>
            <script>
                document.getElementById('configForm').addEventListener('submit', function(e) {
                    e.preventDefault();
                    const apiKey = document.getElementById('apiKey').value;
                    const config = btoa(JSON.stringify({ apiKey: apiKey }));
                    window.location.href = 'stremio://' + window.location.host + '/manifest.json?config=' + config;
                });
            </script>
        </body>
        </html>
    `;
    
    res.setHeader('content-type', 'text/html');
    res.end(landingHTML);
});

// Rota de stream do Stremio
app.get('/stream/:type/:id.json', async (req: any, res: any) => {
    try {
        const { type, id } = req.params;
        const config = req.query.config ? JSON.parse(Buffer.from(req.query.config as string, 'base64').toString()) : {};
        
        // Usar a mesma lógica do handler original
        if (!config || !config.apiKey) {
            return res.json({ streams: [] });
        }

        const streamRequest: StreamRequest = {
            type: type as 'movie' | 'series',
            id: id,
            title: '',
            apiKey: config.apiKey,
            config: {
                quality: 'Todas as Qualidades',
                maxResults: '15 streams',
                language: 'pt-BR',
                enableAggressiveSearch: true,
                minSeeders: 2,
                requireExactMatch: false,
                maxConcurrentTorrents: 8
            }
        };

        const result = await streamHandler.handleStreamRequest(streamRequest);
        res.json(result);
        
    } catch (error) {
        logger.error('Erro na rota de stream', {
            error: error instanceof Error ? error.message : 'Unknown error'
        });
        res.json({ streams: [] });
    }
});

// === ROTAS CUSTOMIZADAS PARA O MODO TORRENTIO-LIKE ===

// Health check
app.get('/health', (req: any, res: any) => {
    res.json({ 
        status: 'ok', 
        service: 'Brasil RD Addon', 
        mode: 'torrentio-like-dev',
        version: manifest.version,
        features: {
            cache: true,
            lazyStreams: true,
            realDebrid: true,
            optimizations: true
        }
    });
});

// Rota de resolução sob demanda (OTIMIZADA COM CACHE SERVICE)
app.get('/resolve/:magnet', async (req: any, res: any) => {
    const encodedMagnet = req.params.magnet;
    const apiKey = req.query.apiKey as string;

    // CACHE: Verificar se já temos este magnet resolvido
    const cacheKey = `resolve:${encodedMagnet}:${apiKey}`;
    const cachedDirectLink = cacheService.get<string>(cacheKey);
    
    if (cachedDirectLink) {
        logger.info('Cache HIT para magnet resolvido', {
            cacheKey,
            directLink: cachedDirectLink.substring(0, 100) + '...'
        });
        return res.redirect(302, cachedDirectLink);
    }

    try {
        const magnet = Buffer.from(encodedMagnet, 'base64').toString();
        logger.info('Resolvendo magnet sob demanda', {
            magnet: magnet.substring(0, 100) + '...',
            apiKey: apiKey ? apiKey.substring(0, 8) + '...' : 'none',
            cacheMiss: true
        });

        if (!apiKey) {
            return res.status(400).json({
                success: false,
                error: 'API key do Real-Debrid é obrigatória'
            });
        }

        // Instanciar o RealDebridService
        const rdService = new RealDebridService();
        
        // 1. Verificar se o torrent já existe no Real-Debrid
        const magnetHash = magnet.match(/btih:([a-zA-Z0-9]+)/i)?.[1];
        let existingTorrent = null;
        
        if (magnetHash) {
            existingTorrent = await rdService.findExistingTorrent(magnetHash, apiKey);
        }

        let torrentId: string;
        
        if (existingTorrent && existingTorrent.id) {
            // OTIMIZAÇÃO: Usar torrent existente
            torrentId = existingTorrent.id;
            logger.info('Torrent já existe no Real-Debrid', { 
                torrentId,
                status: existingTorrent.status,
                progress: existingTorrent.progress
            });
        } else {
            // 2. Processar o magnet no Real-Debrid
            const processResult = await rdService.processTorrent(magnet, apiKey);
            
            if (!processResult.added || !processResult.torrentId) {
                throw new Error('Falha ao adicionar magnet no Real-Debrid');
            }

            torrentId = processResult.torrentId;
            logger.info('Magnet adicionado ao Real-Debrid', { torrentId });
        }

        // 3. Aguardar e buscar informações do torrent (com timeout inteligente)
        let torrentInfo;
        let attempts = 0;
        const maxAttempts = existingTorrent?.status === 'downloaded' ? 1 : 30; // OTIMIZAÇÃO: Menos tentativas se já estiver baixado
        
        while (attempts < maxAttempts) {
            torrentInfo = await rdService.getTorrentInfo(torrentId, apiKey);
            
            if (torrentInfo.status === 'downloaded') {
                logger.info('Torrent pronto no Real-Debrid', { 
                    torrentId,
                    totalAttempts: attempts + 1
                });
                break;
            }
            
            if (torrentInfo.status === 'downloading' || torrentInfo.status === 'queued' || torrentInfo.status === 'uploading') {
                const progress = Math.round(torrentInfo.progress);
                logger.info('Aguardando download do torrent', { 
                    torrentId, 
                    progress: `${progress}%`,
                    attempt: attempts + 1
                });
                
                // OTIMIZAÇÃO: Aumentar intervalo conforme progresso
                const delay = progress > 80 ? 2000 : 1000; // 2 segundos se estiver perto do fim
                await new Promise(resolve => setTimeout(resolve, delay));
                attempts++;
            } else {
                throw new Error(`Status do torrent não suportado: ${torrentInfo.status}`);
            }
        }

        if (attempts >= maxAttempts || !torrentInfo) {
            throw new Error('Timeout aguardando download do torrent');
        }

        // 4. Encontrar o arquivo de vídeo principal
        const videoFiles = (torrentInfo.files || []).filter(file =>
            /\.(mp4|mkv|avi|mov|wmv|flv|webm|m4v|mpg|mpeg|ts|mts|vob)$/i.test(file.path)
        );

        if (videoFiles.length === 0) {
            throw new Error('Nenhum arquivo de vídeo encontrado no torrent');
        }

        // OTIMIZAÇÃO: Ordenar por prioridade (maior arquivo primeiro, mas considerar qualidade no nome)
        const sortedFiles = videoFiles
            .map(file => {
                let priority = file.bytes; // Tamanho como base
                
                // Priorizar arquivos com qualidade no nome
                if (/1080p|720p|2160p|4k/i.test(file.path)) {
                    priority *= 1.5;
                }
                
                // Penalizar arquivos com "sample" ou "trailer"
                if (/sample|trailer|teaser/i.test(file.path)) {
                    priority *= 0.1;
                }
                
                return { ...file, priority };
            })
            .sort((a, b) => b.priority - a.priority);

        const mainFile = sortedFiles[0];
        logger.info('Arquivo de vídeo principal selecionado', {
            filename: mainFile.path,
            size: mainFile.bytes,
            priority: Math.round(mainFile.priority / mainFile.bytes * 100) / 100
        });

        // 5. Gerar link direto
        const directLink = await rdService.getStreamLinkForFile(torrentId, mainFile.id, apiKey);
        
        if (!directLink) {
            throw new Error('Falha ao gerar link direto do arquivo');
        }

        // CACHE: Salvar resultado no cache usando CacheService
        cacheService.set(cacheKey, directLink, CACHE_TTL);

        logger.info('Redirecionando para link direto do Real-Debrid', {
            directLink: directLink.substring(0, 100) + '...',
            cached: true
        });

        // 6. Redirecionar para o link direto
        res.redirect(302, directLink);

    } catch (error) {
        logger.error('Erro ao resolver magnet', {
            error: error instanceof Error ? error.message : 'Unknown error',
            cacheKey
        });
        res.status(500).json({
            success: false,
            error: 'Falha ao resolver o stream: ' + (error instanceof Error ? error.message : 'Unknown error')
        });
    }
});

// Rota para limpar cache (útil para desenvolvimento)
app.delete('/cache', (req: any, res: any) => {
    cacheService.clear();
    logger.info('Cache limpo manualmente');
    res.json({ 
        success: true, 
        message: 'Cache limpo'
    });
});

// Rota para status do cache
app.get('/cache/status', (req: any, res: any) => {
    res.json({
        status: 'CacheService em uso',
        ttl: CACHE_TTL + 'ms',
        feature: 'Cache distribuído por chave'
    });
});

// Rota raiz redireciona para configuração
app.get('/', (req: any, res: any) => {
    res.redirect('/configure');
});

// Iniciar servidor
const port = process.env.PORT ? parseInt(process.env.PORT) : 7000;

app.listen(port, () => {
    logger.info('Brasil RD Addon iniciado com Express customizado', {
        port: port,
        configurable: true,
        environment: process.env.NODE_ENV || 'development',
        cacheEnabled: true,
        optimizations: true
    });

    console.log('=== BRASIL RD ADDON (TORRENTIO MODE) - OTIMIZADO ===');
    console.log(`Addon rodando: http://localhost:${port}/manifest.json`);
    console.log(`Interface de config: http://localhost:${port}/configure`);
    console.log(`Health check: http://localhost:${port}/health`);
    console.log(`Rota de resolução: http://localhost:${port}/resolve/{magnet}?apiKey=...`);
    console.log('');
    console.log('    OTIMIZACOES IMPLEMENTADAS:');
    console.log('   • Cache inteligente de 24h para links resolvidos');
    console.log('   • Verificacao de torrents existentes no Real-Debrid');
    console.log('   • Timeout adaptativo baseado no progresso do download');
    console.log('   • Selecao inteligente de arquivos por qualidade');
    console.log('   • Logs detalhados de performance');
    console.log('   • Uso correto do CacheService');
    console.log('');
    console.log('    ESTATISTICAS:');
    console.log('   • Cache TTL: 24 horas');
    console.log('   • Timeout maximo: 30 segundos');
    console.log('   • Verificacao de torrents existentes');
    console.log('   • Selecao por qualidade + tamanho');
    console.log('');
    console.log('    PROXIMAS OTIMIZACOES:');
    console.log('   • Multiplas qualidades por stream');
    console.log('   • Suporte avancado a series');
    console.log('   • Tratamento de erros com retry');
    console.log('   • Timeouts configuraveis por tamanho');
    console.log('   • Cache distribuído para produção');
    console.log('');
    console.log('    PLATAFORMAS SUPORTADAS:');
    console.log('   • Desktop (Windows, macOS, Linux)');
    console.log('   • Mobile (Android, iOS)');
    console.log('   • TV (Android TV, Smart TVs)');
});